# 교착 상태(Deadlock)

# 교착 상태란?

교착 상태란 하나 이상의 프로세스가 이미 점유된 자원을 무한정 기다리며 대기 상태에서 벗어날 수 없는 상황을 말한다.

# 정상적인 프로세스 자원 사용 단계

1. 요청: 프로세스는 자원을 요청한다. 요청이 즉시 허용되지 않는 경우 자원을 할당받을 때까지 대기한다.
2. 사용: 프로세스는 자원에 대해 작업을 수행한다.
3. 프로세스가 자원을 다 사용하였다면 방출한다.

# 교착 상태의 특징(필요 조건)

1. 상호 배제(Mutual Exclusion)
: 한 번에 한 프로세스만 자원을 사용한다.
2. 점유와 대기(Hold and Wait)
: 최소한 하나의 자원을 점유한 채, 현재 다른 프로세스에 의해 점유된 자원을 추가로 얻기 위해 반드시 대기해야 한다.
3. 비선점(No Preemption)
: 자원들을 선점하지 못한다.
4. 순환 대기(Circular Wait)
: 대기하고 있는 프로세스들의 집합 {P0, P1, ..., Pn}에서 P0는 P1이 점유한 자원을 대기하고, Pn-1은 계속해서 Pn을 대기하며 Pn은 P0가 점유한 자원을 요청하기 위해 대기함

# 자원 할당 그래프 (Resource-Allocation Graph)

교착 상태는 시스템 자원 할당 그래프라고 하는 방향 그래프로 보다 정확하게 기술할 수 있다. 정점 V의 집합과 간선 E의 집합으로 구성된다.

**V = 정점들의 집합 = P + R**

- P = 시스템 내의 모든 프로세스들의 집합 = {P0, P1, ..., Pn}
- R = 시스템 내의 모든 자원들로 구성된 집합 = {R0, R1, ..., Rn}

**E = 간선들의 집합**

- 요청 간선(Request Edge): Pi → Rj: 프로세스 Pi가 자원 Rj를 요청하고 기다리고 있는 상태
- 할당 간선(Assignment Edge): Rj → Pi: 자원 Rj가 프로세스 Pi에게 할당된 것

자원 할당 그래프의 정의로부터 그래프가 사이클을 포함하지 않으면 시스템 내 어느 프로세스도 교착 상태가 아님을 볼 수 있다. 반면, 그래프가 사이클을 포함하면 교착 상태가 존재할 수 있다.

![Deadlock%2036212ea4617a43df91acf07c4ee10f20/Untitled.png](Deadlock%2036212ea4617a43df91acf07c4ee10f20/Untitled.png)

교착 상태를 포함하지 않는 자원 할당 그래프

![Deadlock%2036212ea4617a43df91acf07c4ee10f20/Untitled%201.png](Deadlock%2036212ea4617a43df91acf07c4ee10f20/Untitled%201.png)

교착 상태를 포함하는 자원 할당 그래프

# 교착 상태 처리 방법

1. 시스템이 결코 교착 상태가 되지 않도록 보장하기 위해 교착 상태를 예방하거나 회피하는 프로토콜을 사용
2. 시스템이 교착 상태가 되도록 허용한 다음에 회복시키는 방법
3. 문제를 무시하고, 교착 상태가 시스템에서 결코 발생하지 않는 척하는 방법

세 번째 방식이 현대의 운영체제들이 대부분 사용하는 방식이며, 이 경우 교착 상태를 처리하는 것은 개발자의 몫이다.

## 교착 상태 예방

앞서 얘기한 교착 상태의 필요 조건들 중 적어도 하나가 성립하지 않도록 보장해야 한다.

1. 상호 배제
    - 원인: 자원이 공유가 불가능하다는 점
    - 해결: 파일을 읽기 전용으로 접근
    - 예외: 특정 자원들은 근본적으로 공유가 불가능하여 상호 배제가 반드시 만족해야 하는 경우
2. 점유하며 대기

    자원을 요청할 때 다른 자원들을 점유하지 않고 있다는 것을 반드시 보장해야 한다.

    1. 프로세스가 실행되기 전에 자신이 필요한 모든 자원을 요청하여 할당받도록 하는 방법
        - 많은 자원들이 할당된 후 오랫동안 사용되지 않기 때문에 자원의 이용률이 낮아짐
        - 기아 상태가 발생할 수 있음
    2. 프로세스가 자원을 전혀 점유하지 않을 때만 자원을 요청할 수 있도록 하는 방법
        - 자원의 이용률이 낮아짐
3. 비선점

    자신이 점유하고 있는 자원을 강제로 방출시켜 다른 프로세스가 선점하게 하여 교착 상태를 끊는 프로토콜을 사용해야 한다.

4. 순환 대기

    모든 자원 유형들에게 전체적인 순서를 부여한다. 이를 통해 모든 자원들은 먼저 할당되는 순서가 정해져 있기 때문에 교착 상태를 예방할 수 있다.

### 교착 상태 예방의 단점

대체로 모든 교착 상태 예방법은 장치의 이용률과 시스템 처리율이 감소한다는 단점이 있다.

## 교착 상태 회피

어떤 프로세스가 요청을 할 때 미래에 대한 분석을 통해 나의 요청을 늦추는 방법으로 교착 상태를 피하는 방법. 이러한 교착 상태 회피 알고리즘을 위해서는 각 프로세스가 요청할 각 유형의 자원의 최대 개수를 파악하는 것이다.

### 안전 상태

어떤 순서로 자원을 요청하더라도 교착 상태를 야기하지 않고 원활하게 할당해줄 수 있는 상태를 말한다. 교착 상태 회피 알고리즘은 시스템이 정해진 최대 자원 내에서 시스템이 항상 안전 상태에 있도록 제한한다. 시스템이 안정 상태가 유지될 수 있는 경우에만 요청을 승인하며, 그럴 수 없다면 프로세스를 대기시킨다.

## 교착 상태 탐지 알고리즘 사용

- 조건
    - 교착 상태가 얼마나 자주 일어나는가?
    - 교착 상태가 일어나면 통상 몇 개의 프로세스가 연루되는가?
- 교착 상태가 자주 일어난다면 탐지 알고리즘도 자주 실행해야 한다.
- 교착 상태가 일어나는 시점은 "어떤 프로세스가 자원을 요청했는데 그것이 즉시 만족되지 못한 시점"이다.
- 한 시간에 한 번, 또는 cpu 이용률이 일정 수준 이하로 떨어질 때마다 호출한다.

## 교착 상태 회복

1. 프로세스 종료
    - 교착 상태 프로세스를 모두 종료한다. → 상당히 큰 비용이 발생
    - 교착 상태가 제거될 때까지 한 프로세스씩 중지한다. → 하나씩 중지하면서 교착 상태인지를 매번 확인해야 하기 때문에 상당한 오버헤드를 유발
2. 자원 선점
    - 희생자 선택 (Selection of a Victim): 어떤 프로세스가 어떤 자원을 강제로 방출해야 하는가를 결정
    - 롤백(Rollback): 희생자 선택 후 중지 및 재시작
    - 기아 상태(Starvation): 반복적으로 희생자가 되는 프로세스는 기아 상태에 빠질 수 있다. 따라서 프로세스가 한정된 시간에만 희생자로 선정된다는 것을 반드시 보장해야 한다.

# 참조 및 출처

[[운영체제] 7장 교착상태](https://blog.naver.com/PostView.nhn?blogId=yeop9657&logNo=220728446057&parentCategoryNo=&categoryNo=123&viewDate=&isShowPopularPosts=true&from=search)

[운영체제 | 교착상태(deadlock)란 무엇인가?](https://frontalnh.github.io/2018/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-deadlock-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%AA%A8%EB%8D%B8)